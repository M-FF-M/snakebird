class AVLTreeNode{constructor(t,x){this._cmpFct=t,this.h=0,this.key=x,this.balance=0,this.left=null,this.right=null}height(){return this.h}_leftHeight(){return null==this.left?0:this.left.height()+1}_rightHeight(){return null==this.right?0:this.right.height()+1}_heightDiff(){return this.balance=this._rightHeight()-this._leftHeight()}find(t){return!(0!=this._cmpFct(t,this.key.data))||(0<this._cmpFct(t,this.key.data)?null!=this.right&&this.right.find(t):null!=this.left&&this.left.find(t))}findRightChild(t,x,y){if(null!=this.right){const z=this.right.findRightChild(this,!0,y);if(y){if(this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),null==t)throw new Error("Can't rebalance tree without knowing the parent node");x?t.right=this.checkForValidity():t.left=this.checkForValidity()}return z}const z=this;if(y){if(null==t)throw new Error("Can't remove node without knowing the parent node");null==this.left?(x?t.right=null:t.left=null,this.left=null,this.right=null):(x?t.right=this.left:t.left=this.left,this.left=null,this.right=null),this.h=0}return z}findLeftChild(){return null==this.left?this.key.data:this.left.findLeftChild()}insert(t,x){const y=this.insertHelper(t,x);if(y!=this)throw new Error("Insert requested a parent node change. Use insertHelper instead.")}remove(t,x){const y=this.removeHelper(t,x);if(y!=this)throw new Error("Remove requested a parent node change. Use removeHelper instead.")}insertHelper(t,x){return 0==this._cmpFct(t.data,this.key.data)?this:(0<this._cmpFct(t.data,this.key.data)?null==this.right?(x.insertLinkAfter(this.key,t),this.right=new AVLTreeNode(this._cmpFct,t)):this.right=this.right.insertHelper(t,x):null==this.left?(x.insertLinkBefore(this.key,t),this.left=new AVLTreeNode(this._cmpFct,t)):this.left=this.left.insertHelper(t,x),this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),this.checkForValidity())}removeHelper(t,x){if(0==this._cmpFct(t,this.key.data)){if(x.removeLink(this.key),null!=this.left&&null!=this.right){const y=this.left.findRightChild(this,!1,!0);return y.left=this.left,y.right=this.right,y.h=Math.max(y._leftHeight(),y._rightHeight()),y._heightDiff(),y.checkForValidity()}return null==this.left?null==this.right?null:this.right:this.left}return 0<this._cmpFct(t,this.key.data)?null!=this.right&&(this.right=this.right.removeHelper(t,x)):null!=this.left&&(this.left=this.left.removeHelper(t,x)),this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),this.checkForValidity()}checkForValidity(){if(1>=Math.abs(this._heightDiff()))return this;let t=this.right,x=!1,y=1;if(0>this._heightDiff()&&(t=this.left,x=!0,y=-1),0<=t._heightDiff()*y){const z=t.left,A=t.right;if(x){const B=this.left;return this.left=A,this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),B.left=z,B.right=this,B.h=Math.max(B._leftHeight(),B._rightHeight()),B._heightDiff(),B}const B=this.right;return this.right=z,this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),B.left=this,B.right=A,B.h=Math.max(B._leftHeight(),B._rightHeight()),B._heightDiff(),B}const z=t.left,A=t.right;if(x){const B=this.left,C=A.left,D=A.right;return this.left=D,this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),B.right=C,B.h=Math.max(B._leftHeight(),B._rightHeight()),B._heightDiff(),A.left=B,A.right=this,A.h=Math.max(A._leftHeight(),A._rightHeight()),A._heightDiff(),A}const B=this.right,C=z.left,D=z.right;return this.right=C,this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),B.left=D,B.h=Math.max(B._leftHeight(),B._rightHeight()),B._heightDiff(),z.left=this,z.right=B,z.h=Math.max(z._leftHeight(),z._rightHeight()),z._heightDiff(),z}toString(){return this._dotNode(0)[0]}_dotNode(t){let x="\t"+t+" [label=\""+this.key.data+", b="+this.balance+"\"];\n",y=t+1;if(null!=this.left){const[z,A]=this.left._dotLink(t,y,"l");x+=z,y=A}if(null!=this.right){const[z,A]=this.right._dotLink(t,y,"r");x+=z,y=A}return[x,y]}_dotLink(t,x,y){let z="\t"+t+" -> "+x+" [label=\""+y+"\"];\n";const[A,B]=this._dotNode(x);return z+=A,x=B,[z,x]}}class AVLTree{constructor(t=(x,y)=>x-y){this._cmpFct=t,this._root=null,this._list=new DoublyLinkedList}get length(){return this._list.length}insert(t){if(null==this._root){const x=this._list.pushBack(t);this._root=new AVLTreeNode(this._cmpFct,x)}else{const x=new DoubleLink(t,null,null);this._root=this._root.insertHelper(x,this._list)}}remove(t){null==this._root||(1==this.length?this._root.key.data==t&&(this._list.popBack(),this._root=null):this._root=this._root.removeHelper(t,this._list))}find(t){return null!=this._root&&this._root.find(t)}contains(t){return this.find(t)}toArray(){return this._list.toArray()}toString(){let t="digraph {\n";return null!=this._root&&(t+=this._root.toString()),t+="}",t}isEmpty(){return 0==this.length}}class TreeSet extends AVLTree{constructor(t=(x,y)=>x-y){super(t)}}class BinaryHeap{constructor(...t){if(this._data=[],this.length=0,0<t.length){t[0]instanceof Array&&(t=t[0]),this._data=t.slice(),this.length=this._data.length;for(let x=Math.floor(this.length/2)-1;0<=x;x--)this._siftDown(x)}}_swap(t,x){let y=this._data[t];this._data[t]=this._data[x],this._data[x]=y}_siftUp(t){for(;0<t&&this._data[Math.floor((t-1)/2)]>this._data[t];)this._swap(t,Math.floor((t-1)/2)),t=Math.floor((t-1)/2)}_siftDown(t){for(let x;2*t+1<this.length;){if(x=2*t+2>=this.length?2*t+1:this._data[2*t+1]<this._data[2*t+2]?2*t+1:2*t+2,this._data[t]<=this._data[x])return;this._swap(t,x),t=x}}min(){if(0==this.length)throw new RangeError("BinaryHeap: can't call min() on an empty heap.");return this._data[0]}deleteMin(){let t=this._data[0];return this.length--,this._data[0]=this._data[this.length],this._data.pop(),this._siftDown(0),t}insert(t){this._data[this.length]=t,this._siftUp(this.length),this.length++}isEmpty(){return 0==this.length}}class CustomBinaryHeap{constructor(t=(y,z)=>y-z,...x){if(this._data=[],this.cmpFct=t,this.length=0,0<x.length){x[0]instanceof Array&&(x=x[0]),this._data=x.slice(),this.length=this._data.length;for(let y=Math.floor(this.length/2)-1;0<=y;y--)this._siftDown(y)}}_swap(t,x){let y=this._data[t];this._data[t]=this._data[x],this._data[x]=y}_siftUp(t){for(;0<t&&0<this.cmpFct(this._data[Math.floor((t-1)/2)],this._data[t]);)this._swap(t,Math.floor((t-1)/2)),t=Math.floor((t-1)/2)}_siftDown(t){for(let x;2*t+1<this.length;){if(x=2*t+2>=this.length?2*t+1:0>this.cmpFct(this._data[2*t+1],this._data[2*t+2])?2*t+1:2*t+2,0>=this.cmpFct(this._data[t],this._data[x]))return;this._swap(t,x),t=x}}min(){if(0==this.length)throw new RangeError("BinaryHeap: can't call min() on an empty heap.");return this._data[0]}deleteMin(){let t=this._data[0];return this.length--,this._data[0]=this._data[this.length],this._data.pop(),this._siftDown(0),t}insert(t){this._data[this.length]=t,this._siftUp(this.length),this.length++}isEmpty(){return 0==this.length}}class PriorityQueue extends CustomBinaryHeap{constructor(t=(y,z)=>y-z,...x){super(t,...x)}}class BinomialTreeNode{constructor(t){this.key=t,this.children=[]}min(){return this.key}rank(){return this.children.length}deleteMin(){const t=this.children.slice();return this.children=[],t}addChild(t){if(!(t instanceof BinomialTreeNode))throw new Error("BinomialTreeNode: child must be of type BinomialTreeNode.");if(t.rank()!=this.rank())throw new Error("BinomialTreeNode: Can't add tree of rank "+t.rank()+" to a tree of rank "+this.rank()+".");return this.children.push(t),this}}function merge(t,x){return t.min()<=x.min()?t.addChild(x):x.addChild(t)}class BinomialHeap{constructor(...t){if(this._trees=[],this.length=0,0<t.length)if(t[0]instanceof Array&&(t=t[0]),1==t.length&&!(t[0]instanceof BinomialTreeNode))this._trees.push(new BinomialTreeNode(t[0])),this.length=1;else for(let x=0;x<t.length;x++)this._trees.push(t[x]),this.length+=1<<t[x].rank()}min(){if(0==this._trees.length)throw new RangeError("BinomialHeap: can't call min() on an empty heap.");let t=Infinity;for(let x=0;x<this._trees.length;x++)this._trees[x].min()<t&&(t=this._trees[x].min());return t}insert(t){const x=new BinomialHeap(t);this.mergeWith(x)}deleteMin(){if(0==this._trees.length)throw new RangeError("Can't call deleteMin() on an empty heap.");let t=Infinity,x=null,y=0;for(let A=0;A<this._trees.length;A++)this._trees[A].min()<t&&(t=this._trees[A].min(),x=this._trees[A],y=A);const z=new BinomialHeap(x.deleteMin());return this.length-=z.length+1,this._trees.splice(y,1),this.mergeWith(z),t}mergeWith(t){let x=0,y=0;const z=[];let A=-1;for(this.length+=t.length;x<this._trees.length||y<t._trees.length;){let B=null,C=null,D=Infinity,F=Infinity;if(x<this._trees.length&&(B=this._trees[x],D=B.rank()),y<t._trees.length&&(C=t._trees[y],F=C.rank()),D<F)x++;else if(D>F){y++;const H=F,I=C;F=D,C=B,D=H,B=I}let G;if(D==F?(x++,y++,G=merge(B,C)):G=B,G.rank()>A)z.push(G),A=G.rank();else{if(G.rank()<A)throw new Error("The developer obviously didn't understand how binomial heaps work...");G=merge(G,z[z.length-1]),z[z.length-1]=G,A=G.rank()}}this._trees=z}isEmpty(){return 0==this._trees.length}}class E{constructor(t){this.v=t}}class WE{constructor(t,x){this.v=t,this.w=x}}class Graph{constructor(t){this.n=t,this._weighted=!1,this.adjList=[],this.adjListRev=[],this._nodeMap=new Map;for(let x=0;x<this.n;x++)this.adjList[x]=[],this.adjListRev[x]=[]}getSCCGraph(){const t=[],x=[],y=[],z=-1,A=0,C=[];let D=0;for(let L=0;L<this.n;L++)t[L]=z,x[L]=z,y[L]=z,C[L]=-1;const F=new Queue,G=new Queue,H=[],I=[],J=L=>{const M=new Set;t[L]=x[L]=D++,F.pushBack(L),G.pushBack(M),y[L]=A;for(let N=0;N<this.adjList[L].length;N++){const O=this.adjList[L][N].v;if(x[O]==z){const P=J(O);-1!=P&&M.add(P)}else-1!=C[O]&&M.add(C[O]);y[O]==A&&(t[L]=Math.min(t[L],t[O]))}if(t[L]==x[L]){const N=[];for(;;){const O=F.popBack();y[O]=1,C[O]=H.length,N.push(this.getNode(O));const P=G.popBack();if(L==O)break;for(const Q of P)M.add(Q)}H.push(N);for(const O of M)I.push([H.length-1,O]);return H.length-1}return-1};for(let L=0;L<this.n;L++)x[L]==z&&J(L);const K=new Graph(H.length);for(let L=0;L<I.length;L++)K.insertEdge(I[L][0],I[L][1]);for(let L=0;L<H.length;L++)K.setNode(L,H[L]);return K}topSort(){const t=[];let x=0;const y=[],z=new Queue;for(let A=0;A<this.n;A++)t[A]=this.adjList[A].length,0==t[A]&&(x++,z.pushBack(A),y.push(this.getNode(A)));for(;!z.isEmpty();){const A=z.popFront();for(let B=0;B<this.adjListRev[A].length;B++){const C=this.adjListRev[A][B].v;t[C]--,0==t[C]&&(x++,z.pushBack(C),y.push(this.getNode(C)))}}return x==this.n?y.reverse():null}isAcyclic(){return null!==this.topSort()}insertEdge(t,x,y){"number"==typeof y?(this.adjList[t].push(new WE(x,y)),this.adjListRev[x].push(new WE(t,y)),this._weighted=!0):(this.adjList[t].push(new E(x)),this.adjListRev[x].push(new E(t)))}insertUndirectedEdge(t,x,y){this.insertEdge(t,x,y),this.insertEdge(x,t,y)}getNode(t){return this._nodeMap.has(t)?this._nodeMap.get(t):t}setNode(t,x){this._nodeMap.set(t,x)}getAllNodes(){const t=[];for(let x=0;x<this.n;x++)t.push(this.getNode(x));return t}}class HashSet{constructor(t=x=>x){this._toKeyFct=t,this._hashMap={},this.length=0}insert(t){this._hashMap.hasOwnProperty(this._toKeyFct(t))||(this._hashMap[this._toKeyFct(t)]=t,this.length++)}remove(t){this._hashMap.hasOwnProperty(this._toKeyFct(t))&&(this._hashMap[this._toKeyFct(t)]=void 0,delete this._hashMap[this._toKeyFct(t)],this.length--)}find(t){return this._hashMap.hasOwnProperty(this._toKeyFct(t))}contains(t){return this.find(t)}toArray(){const t=[];for(const x in this._hashMap)this._hashMap.hasOwnProperty(x)&&t.push(this._hashMap[x]);return t}isEmpty(){return 0==this.length}}class ListHashSet{constructor(t=x=>x){this._toKeyFct=t,this._hashMap={},this.list=new DoublyLinkedList}get length(){return this.list.length}insert(t){"undefined"==typeof this._hashMap[this._toKeyFct(t)]&&(this._hashMap[this._toKeyFct(t)]=this.list.pushBack(t))}remove(t){"undefined"!=typeof this._hashMap[this._toKeyFct(t)]&&(this.list.removeLink(this._hashMap[this._toKeyFct(t)]),this._hashMap[this._toKeyFct(t)]=void 0)}find(t){return"undefined"!=typeof this._hashMap[this._toKeyFct(t)]}contains(t){return this.find(t)}toArray(){return this.list.toArray()}isEmpty(){return 0==this.length}}class SingleLink{constructor(t,x){this.data=t,this.next=x}}class DoubleLink{constructor(t,x,y){this.data=t,this.last=x,this.next=y}}class LinkedList{constructor(...t){if(1==t.length&&t[0]instanceof Array&&(t=t[0]),this.length=0,this.first=null,0<t.length){t=t.slice().reverse(),this.length=t.length,this.first=new SingleLink(t[0],null);let x=this.first;for(let y=1;y<this.length;y++)x.next=new SingleLink(t[y],null),x=x.next}}get(t){if(0>t)throw new RangeError("LinkedList: index "+t+" is out of bounds length is "+this.length+".");if(t>=this.length)throw new RangeError("LinkedList: index "+t+" is out of bounds length is "+this.length+".");t=this.length-t-1;let x=this.first;for(let y=0;y<this.length;y++){if(y==t)return x.data;x=x.next}}removeIdx(t){if(0>t)throw new RangeError("LinkedList: index "+t+" is out of bounds length is "+this.length+".");if(t>=this.length)throw new RangeError("LinkedList: index "+t+" is out of bounds length is "+this.length+".");if(t=this.length-t-1,0==t)this.first=this.first.next;else{let x=this.first,y=this.first.next;for(let z=1;z<this.length;z++){if(z==t){x.next=y.next;break}x=y,y=y.next}}this.length--}removeObj(t){let x=!1;if(t===this.first.data)this.first=this.first.next,x=!0;else{let y=this.first,z=this.first.next;for(let A=1;A<this.length;A++){if(t===z.data){y.next=z.next,x=!0;break}y=z,z=z.next}}return x&&this.length--,x}contains(t){let x=this.first;for(let y=0;y<this.length;y++){if(t===x.data)return!0;x=x.next}return!1}pushBack(t){this.first=new SingleLink(t,this.first),this.length++}getBack(){if(0==this.length)throw new RangeError("LinkedList: cannot get last element from empty list.");return this.first.data}popBack(){if(0==this.length)throw new RangeError("LinkedList: cannot pop last element from empty list.");const t=this.first.data;return this.first=this.first.next,this.length--,t}isEmpty(){return 0==this.length}toString(){let t="]",x=this.first;for(let y=0;y<this.length;y++)0<y&&(t=", "+t),t=x.data+t,x=x.next;return t="LinkedList: ["+t,t}}class DoublyLinkedList{constructor(...t){if(1==t.length&&t[0]instanceof Array&&(t=t[0]),this.length=0,this.first=null,this.last=null,0<t.length){this.length=t.length,this.first=new DoubleLink(t[0],null,null);let x=this.first;for(let y=1;y<this.length;y++)x.next=new DoubleLink(t[y],x,null),x=x.next;this.last=x}}get(t){if(0>t)throw new RangeError("DoublyLinkedList: index "+t+" is out of bounds length is "+this.length+".");if(t>=this.length)throw new RangeError("DoublyLinkedList: index "+t+" is out of bounds length is "+this.length+".");let x=this.first;for(let y=0;y<this.length;y++){if(y==t)return x.data;x=x.next}}removeIdx(t){if(0>t)throw new RangeError("DoublyLinkedList: index "+t+" is out of bounds length is "+this.length+".");if(t>=this.length)throw new RangeError("DoublyLinkedList: index "+t+" is out of bounds length is "+this.length+".");if(0==t)this.first=this.first.next,null!==this.first&&(this.first.last=null);else{let x=this.first,y=this.first.next;for(let z=1;z<this.length;z++){if(z==t){x.next=y.next,null===y.next?this.last=x:y.next.last=x;break}x=y,y=y.next}}this.length--}removeObj(t){let x=!1;if(t===this.first.data)this.first=this.first.next,null!==this.first&&(this.first.last=null),x=!0;else{let y=this.first,z=this.first.next;for(let A=1;A<this.length;A++){if(t===z.data){y.next=z.next,null===z.next?this.last=y:z.next.last=y,x=!0;break}y=z,z=z.next}}return x&&this.length--,x}removeLink(t){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot remove element from empty list.");if(null==t.last&&null==t.next){if(this.first!=t||1!=this.length)throw new Error("DoublyLinkedList: cannot remove link that is not part of the list");this.first=this.last=null}else if(null==t.last){if(this.first!=t)throw new Error("DoublyLinkedList: cannot remove link that is not part of the list");this.first=t.next,t.next.last=null}else if(null==t.next){if(this.last!=t)throw new Error("DoublyLinkedList: cannot remove link that is not part of the list");this.last=t.last,t.last.next=null}else{const x=t.next,y=t.last;x.last=y,y.next=x}this.length--}insertAfter(t,x){const y=t.next;if(null==y){if(this.last!=t)throw new Error("DoublyLinkedList: cannot add element after link that is not part of the list");return this.pushBack(x)}const z=t.next=y.last=new DoubleLink(x,t,y);return this.length++,z}insertBefore(t,x){const y=t.last;if(null==y){if(this.first!=t)throw new Error("DoublyLinkedList: cannot add element before link that is not part of the list");return this.pushFront(x)}const z=t.last=y.next=new DoubleLink(x,y,t);return this.length++,z}insertLinkAfter(t,x){const y=t.next;if(null==y){if(this.last!=t)throw new Error("DoublyLinkedList: cannot add element after link that is not part of the list");return this.last=x,this.last.next=null,this.last.last=t,t.next=this.last,this.length++,x}const z=t.next=y.last=x;return x.last=t,x.next=y,this.length++,z}insertLinkBefore(t,x){const y=t.last;if(null==y){if(this.first!=t)throw new Error("DoublyLinkedList: cannot add element before link that is not part of the list");return this.first=x,this.first.last=null,this.first.next=t,t.last=this.first,this.length++,x}const z=t.last=y.next=x;return x.last=y,x.next=t,this.length++,z}contains(t){let x=this.first;for(let y=0;y<this.length;y++){if(t===x.data)return!0;x=x.next}return!1}pushBack(t){let x;return 0==this.length?x=this.last=this.first=new DoubleLink(t,null,null):(x=this.last.next=new DoubleLink(t,this.last,null),this.last=this.last.next),this.length++,x}getBack(){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot get last element from empty list.");return this.last.data}popBack(){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot pop last element from empty list.");const t=this.last.data;return this.last=this.last.last,null===this.last?this.first=null:this.last.next=null,this.length--,t}pushFront(t){let x;return 0==this.length?x=this.last=this.first=new DoubleLink(t,null,null):(x=this.first.last=new DoubleLink(t,null,this.first),this.first=this.first.last),this.length++,x}getFront(){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot get first element from empty list.");return this.first.data}popFront(){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot pop first element from empty list.");const t=this.first.data;return this.first=this.first.next,null===this.first?this.last=null:this.first.last=null,this.length--,t}toArray(){const t=[];let x=this.first;for(let y=0;y<this.length;y++)t.push(x.data),x=x.next;return t}isEmpty(){return 0==this.length}toString(){let t="DoublyLinkedList: [",x=this.first;for(let y=0;y<this.length;y++)0<y&&(t+=", "),t+=x.data,x=x.next;return t+="]",t}}class Queue{constructor(...t){1==t.length&&t[0]instanceof Array&&(t=t[0]),this._data=t.slice(),this._front=0,this._last=t.length-1,this._size=16,0<t.length?this._size=Math.max(16,1<<Math.ceil(Math.log2(t.length))):this._front=1}get(t){if(0>t)throw new RangeError("Queue: index "+t+" is out of bounds length is "+this.length+".");if(t>=this.length)throw new RangeError("Queue: index "+t+" is out of bounds length is "+this.length+".");return this._data[(this._front+t)%this._size]}contains(t){for(let x=0;x<this.length;x++)if(this._data[(this._front+x)%this._size]===t)return!0;return!1}removeObj(t){let x=-1;for(let y=0;y<this.length;y++)if(this._data[(this._front+y)%this._size]===t){x=y;break}return-1!=x&&(this.removeIdx(x),!0)}removeIdx(t){if(0>t)throw new RangeError("Queue: index "+t+" is out of bounds length is "+this.length+".");if(t>=this.length)throw new RangeError("Queue: index "+t+" is out of bounds length is "+this.length+".");for(let x=t;x<this.length;x++)this._data[x%this._size]=this._data[(x+1)%this._size];--this._last,0>this._last&&(this._last=this._size-1),this._checkFrontShift()}get length(){return 0>this._last?0:this._last>=this._front?this._last-this._front+1:this._size-this._front+this._last+1}_checkFrontShift(){if(this.length<this._size/4){let t=[];for(let x=0;x<this.length;x++)t[x]=this._data[(this._front+x)%this._size];this._data=t,this._front=0,this._last=this._data.length-1,this._size=Math.max(16,1<<Math.ceil(Math.log2(this._data.length)),this._size/2)}}pushBack(t){if(0==this.length)this._data.push(t),this._front=this._last=0;else if(this._last>=this._front)this._data[++this._last]=t,this._last>=this._size&&(this._size*=2);else if(this._last<this._front-1)this._data[++this._last]=t;else{for(let x=0;x<this._size-this._front;x++)this._data[this._front+this._size+x]=this._data[this._front+x];this._front+=this._size,this._size*=2,this._data[++this._last]=t}}getBack(){if(0==this.length)throw new RangeError("Queue: cannot get last element from empty queue.");return this._data[this._last]}popBack(){if(0==this.length)throw new RangeError("Queue: cannot pop last element from empty queue.");const t=this._data[this._last];return 1==this.length?(this._data=[],this._front=1,this._last=-1,this._size=16,t):(--this._last,0>this._last&&(this._last=this._size-1),this._checkFrontShift(),t)}pushFront(t){if(0==this.length)this._data.push(t),this._front=this._last=0;else if(this._last>=this._front)0<this._front?this._data[--this._front]=t:(this._last==this._size-1&&(this._size*=2),this._front=this._size-1,this._data[this._front]=t);else if(this._last<this._front-1)this._data[--this._front]=t;else{for(let x=0;x<this._size-this._front;x++)this._data[this._front+this._size+x]=this._data[this._front+x];this._front+=this._size,this._size*=2,this._data[--this._front]=t}}getFront(){if(0==this.length)throw new RangeError("Queue: cannot get last element from empty queue.");return this._data[this._front]}popFront(){if(0==this.length)throw new RangeError("Queue: cannot pop first element from empty queue.");const t=this._data[this._front];return 1==this.length?(this._data=[],this._front=1,this._last=-1,this._size=16,t):(++this._front,this._front>=this._size&&(this._front=0),this._checkFrontShift(),t)}isEmpty(){return 0==this.length}toString(){let t="Queue: [";for(let x=0;x<this.length;x++)0<x&&(t+=", "),t+=this._data[(this._front+x)%this._size];return t+="]",t}}